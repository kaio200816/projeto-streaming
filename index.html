<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Jogo Fácil EXTREMO</title>
<style>
:root{--bg:#0f1724;--card:#0b1220;--accent:#10b981;}
html,body{height:100%;margin:0;font-family:Inter,sans-serif;color:#e6eef8;background:#050d1a;display:flex;align-items:center;justify-content:center;overflow:hidden}
.wrapper{width:960px;max-width:95%;background:#0b1220;border-radius:12px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,0.6);position:relative;}
header{margin-bottom:12px}
h1{font-size:22px;margin:0}
p.lead{margin:4px 0 0;color:#94a3b8;font-size:13px}
.hud{display:flex;gap:15px;margin-top:10px;}
.pill{background:#1e293b;padding:6px 12px;border-radius:20px;font-size:14px;font-weight:600;}
.difficulty-meter{width:100%;height:8px;background:#1e293b;border-radius:4px;margin-top:10px;overflow:hidden;}
.difficulty-progress{height:100%;background:linear-gradient(90deg, #10b981, #f59e0b, #ef4444);width:0%;transition:width 0.3s ease;}
.game{position:relative;min-height:480px;overflow:hidden; width: 100%;border:2px solid #1e293b;border-radius:8px;}
.big-btn{position:absolute;padding:18px 34px;border-radius:999px;background:green;color:#042018;font-weight:700;cursor:pointer;user-select:none;box-shadow:0 6px 18px rgba(16,185,129,0.25);transition:all 0.3s ease; display:flex;align-items:center;justify-content:center;border:3px solid transparent;font-size:16px;z-index:10;}
.big-btn:hover{transform:scale(1.05);}
.big-btn.danger{border-color:#ef4444;animation:pulse 0.5s infinite alternate;}
.stage{display:none;}
.stage.active{display:block;}
#chapolin{position:absolute;width:100px;height:100px;display:none;z-index:999;transform-origin:center center;}
#chapolinHammer{position:absolute;width:120px;height:120px;display:none;z-index:1000;transform-origin:center center;}
.particle{position:absolute;width:20px;height:20px;background:var(--accent);border-radius:50%;pointer-events:none;}
.volume-indicator{position:absolute;top:10px;right:10px;background:rgba(0,0,0,0.7);padding:5px 10px;border-radius:15px;font-size:12px;display:flex;align-items:center;gap:5px;}
.volume-bar{width:60px;height:4px;background:#374151;border-radius:2px;overflow:hidden;}
.volume-level{height:100%;background:#10b981;width:0%;transition:width 0.3s ease;}
.win-screen{text-align:center;padding:40px;}
.win-screen h2{font-size:32px;margin-bottom:20px;background:linear-gradient(45deg, #10b981, #3b82f6);background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent;}
#playAgain{padding:15px 30px;font-size:18px;margin-top:20px;}

@keyframes pulse {
  from { box-shadow: 0 0 10px rgba(239, 68, 68, 0.5); }
  to { box-shadow: 0 0 20px rgba(239, 68, 68, 0.8); }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

@keyframes megaShake {
  0%, 100% { transform: translate(0, 0) rotate(0deg); }
  10% { transform: translate(-10px, -5px) rotate(-2deg); }
  20% { transform: translate(10px, 5px) rotate(2deg); }
  30% { transform: translate(-8px, 3px) rotate(-1deg); }
  40% { transform: translate(8px, -3px) rotate(1deg); }
  50% { transform: translate(-6px, -2px) rotate(-0.5deg); }
  60% { transform: translate(6px, 2px) rotate(0.5deg); }
  70% { transform: translate(-4px, 1px) rotate(-0.2deg); }
  80% { transform: translate(4px, -1px) rotate(0.2deg); }
  90% { transform: translate(-2px, 0px) rotate(-0.1deg); }
}

@keyframes chapolinSpin {
  0% { transform: rotate(0deg) scale(1); }
  25% { transform: rotate(90deg) scale(1.1); }
  50% { transform: rotate(180deg) scale(1.2); }
  75% { transform: rotate(270deg) scale(1.3); }
  100% { transform: rotate(360deg) scale(1.4); }
}

@keyframes chapolinExplode {
  0% { 
    transform: rotate(0deg) scale(1); 
    filter: brightness(1) hue-rotate(0deg);
  }
  25% { 
    transform: rotate(90deg) scale(1.5); 
    filter: brightness(1.5) hue-rotate(90deg);
  }
  50% { 
    transform: rotate(180deg) scale(2); 
    filter: brightness(2) hue-rotate(180deg);
  }
  75% { 
    transform: rotate(270deg) scale(2.5); 
    filter: brightness(2.5) hue-rotate(270deg);
  }
  100% { 
    transform: rotate(360deg) scale(3); 
    filter: brightness(3) hue-rotate(360deg);
    opacity: 0;
  }
}

@keyframes screenFlash {
  0%, 100% { background-color: transparent; }
  10% { background-color: #ff0000; }
  20% { background-color: #ffff00; }
  30% { background-color: #ff0000; }
  40% { background-color: #ffffff; }
  50% { background-color: #ff0000; }
  60% { background-color: #ffff00; }
  70% { background-color: #ff0000; }
  80% { background-color: #ffffff; }
  90% { background-color: #ff0000; }
}

@keyframes particleExplode {
  0% { 
    transform: translate(0, 0) scale(1) rotate(0deg);
    opacity: 1;
  }
  50% { 
    transform: translate(var(--dx), var(--dy)) scale(1.5) rotate(180deg);
    opacity: 0.8;
  }
  100% { 
    transform: translate(calc(var(--dx) * 2), calc(var(--dy) * 2)) scale(0.5) rotate(360deg);
    opacity: 0;
  }
}

@keyframes shockwave {
  0% { 
    transform: scale(0);
    opacity: 1;
  }
  100% { 
    transform: scale(10);
    opacity: 0;
  }
}

@keyframes textReveal {
  0% { 
    transform: scale(0) rotate(180deg);
    opacity: 0;
  }
  50% { 
    transform: scale(1.2) rotate(0deg);
    opacity: 1;
  }
  100% { 
    transform: scale(1) rotate(0deg);
    opacity: 1;
  }
}

@keyframes chapolinTextShake {
  0%, 100% { 
    transform: translate(0, 0) rotate(0deg) scale(1);
  }
  10% { 
    transform: translate(-5px, -3px) rotate(-1deg) scale(1.05);
  }
  20% { 
    transform: translate(5px, 3px) rotate(1deg) scale(1.05);
  }
  30% { 
    transform: translate(-3px, 2px) rotate(-0.5deg) scale(1.03);
  }
  40% { 
    transform: translate(3px, -2px) rotate(0.5deg) scale(1.03);
  }
  50% { 
    transform: translate(-2px, 1px) rotate(-0.2deg) scale(1.02);
  }
  60% { 
    transform: translate(2px, -1px) rotate(0.2deg) scale(1.02);
  }
  70% { 
    transform: translate(-1px, 0px) rotate(-0.1deg) scale(1.01);
  }
  80% { 
    transform: translate(1px, 0px) rotate(0.1deg) scale(1.01);
  }
  90% { 
    transform: translate(0px, 0px) rotate(0deg) scale(1);
  }
}

@keyframes hammerSwing {
  0% { 
    transform: rotate(-45deg) scale(1);
  }
  25% { 
    transform: rotate(0deg) scale(1.1);
  }
  50% { 
    transform: rotate(45deg) scale(1.2);
  }
  75% { 
    transform: rotate(90deg) scale(1.3);
  }
  100% { 
    transform: rotate(135deg) scale(1.4);
  }
}

@keyframes hammerVictory {
  0% { 
    transform: translate(0, 0) rotate(0deg) scale(1);
    opacity: 0;
  }
  25% { 
    transform: translate(0, -50px) rotate(90deg) scale(1.2);
    opacity: 1;
  }
  50% { 
    transform: translate(0, -100px) rotate(180deg) scale(1.4);
    opacity: 1;
  }
  75% { 
    transform: translate(0, -150px) rotate(270deg) scale(1.6);
    opacity: 1;
  }
  100% { 
    transform: translate(0, -200px) rotate(360deg) scale(2);
    opacity: 0;
  }
}

@keyframes victoryConfetti {
  0% { 
    transform: translateY(0) rotate(0deg);
    opacity: 1;
  }
  100% { 
    transform: translateY(-100vh) rotate(360deg);
    opacity: 0;
  }
}

@keyframes victoryText {
  0% { 
    transform: scale(0) rotate(180deg);
    opacity: 0;
  }
  50% { 
    transform: scale(1.3) rotate(0deg);
    opacity: 1;
  }
  100% { 
    transform: scale(1) rotate(0deg);
    opacity: 1;
  }
}

.shake { animation: shake 0.1s ease-in-out infinite; }
.megaShake { animation: megaShake 0.5s ease-in-out infinite; }
.chapolinSpin { animation: chapolinSpin 0.3s ease-in-out infinite; }
.chapolinExplode { animation: chapolinExplode 2s ease-out forwards; }
.screenFlash { animation: screenFlash 0.1s ease-in-out infinite; }
.particleExplode { animation: particleExplode 2s ease-out forwards; }
.shockwave { animation: shockwave 1s ease-out forwards; }
.textReveal { animation: textReveal 1s ease-out forwards; }
.chapolinTextShake { animation: chapolinTextShake 0.3s ease-in-out infinite; }
.hammerSwing { animation: hammerSwing 0.5s ease-in-out infinite; }
.hammerVictory { animation: hammerVictory 2s ease-out forwards; }
.victoryConfetti { animation: victoryConfetti 3s ease-out forwards; }
.victoryText { animation: victoryText 1s ease-out forwards; }

/* Efeitos Troll */
@keyframes glitch {
  0% { transform: translate(0); }
  20% { transform: translate(-2px, 2px); }
  40% { transform: translate(-2px, -2px); }
  60% { transform: translate(2px, 2px); }
  80% { transform: translate(2px, -2px); }
  100% { transform: translate(0); }
}

@keyframes lag {
  0%, 100% { filter: brightness(1) contrast(1); }
  25% { filter: brightness(1.2) contrast(1.1); }
  50% { filter: brightness(0.8) contrast(0.9); }
  75% { filter: brightness(1.1) contrast(1.05); }
}

@keyframes cursorBreak {
  0%, 100% { transform: translate(0, 0) rotate(0deg); }
  25% { transform: translate(-3px, -2px) rotate(-5deg); }
  50% { transform: translate(3px, 2px) rotate(5deg); }
  75% { transform: translate(-2px, 3px) rotate(-3deg); }
}

@keyframes fakeButton {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.7; transform: scale(0.95); }
}

@keyframes screenFlicker {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.8; }
}

.glitch { animation: glitch 0.1s ease-in-out infinite; }
.lag { animation: lag 0.2s ease-in-out infinite; }
.cursorBreak { animation: cursorBreak 0.1s ease-in-out infinite; }
.fakeButton { animation: fakeButton 0.5s ease-in-out infinite; }
.screenFlicker { animation: screenFlicker 0.1s ease-in-out infinite; }
</style>
</head>
<body>
<audio id="bgMusic" src="https://files.catbox.moe/jh5pww.mp3" loop></audio>
<audio id="explosionSound" preload="auto"></audio>
<audio id="boomSound" preload="auto"></audio>
<audio id="chapolinLaugh" preload="auto"></audio>
<audio id="errorSound" preload="auto"></audio>

<!-- Áudios do Chapolin -->
<audio id="chapolinVictory" src="https://files.catbox.moe/nxqph8.mp3" preload="auto"></audio>
<audio id="chapolinCheat" src="https://files.catbox.moe/39npl3.mp3" preload="auto"></audio>
<audio id="chapolinDefeat1" src="https://files.catbox.moe/dd1pv7.mp3" preload="auto"></audio>
<audio id="chapolinDefeat2" src="https://files.catbox.moe/t0y8fs.mp3" preload="auto"></audio>
<audio id="chapolinDefeat3" src="https://files.catbox.moe/xvp157.mp3" preload="auto"></audio>
<audio id="chapolinDefeat4" src="https://files.catbox.moe/3ij0xb.mp3" preload="auto"></audio>

<div class="wrapper">
  <header>
    <h1>🎮 Jogo Fácil (Mas Nem Tanto!)</h1>
    <p class="lead">Pegue o botão verde antes que o Chapolin ou o tempo acabem!</p>
    
    <div class="hud">
      <div class="pill">🎯 Tentativas: <span id="attempts">0</span>/30</div>
      <div class="pill">⚡ Dificuldade: <span id="difficulty">Fácil</span></div>
      <div class="pill">🏆 Stage: <span id="stage">1</span></div>
    <div class="pill" id="cheatIndicator" style="display: none;">💎 CHEAT ATIVO</div>
    </div>
    
    <div class="difficulty-meter">
      <div id="difficultyProgress" class="difficulty-progress"></div>
    </div>
  </header>
  
  <div class="volume-indicator">
    <span>🔊</span>
    <div class="volume-bar">
      <div id="volumeLevel" class="volume-level"></div>
    </div>
    <span id="volumeText">0%</span>
  </div>
  
  <main class="game">
    <div id="stage1" class="stage active">
      <div id="btn1" class="big-btn">🎯 VENCER 🎯</div>
      <img id="chapolin" src="https://files.catbox.moe/tq0ox6.png">
      <img id="chapolinHammer" src="https://files.catbox.moe/2z71jo.png" style="display: none;">
    </div>
    
    <div id="winScreen" class="stage win-screen">
      <h2>🎉 VOCÊ VENCEU! 🎉</h2>
      <p>Você conseguiu pegar o botão verde com <span id="finalAttempts">0</span> tentativas!</p>
      <button id="playAgain" class="big-btn">🔄 Jogar de novo</button>
    </div>
  </main>
</div>

<script>
// ===========================================
// SISTEMA ANTI-DEVTOOL - PROTEÇÃO MÁXIMA
// ===========================================

// Variáveis de controle anti-devtool
let devToolsOpen = false;
let devToolsAttempts = 0;
let isDebugging = false;
let lastWindowSize = { width: window.innerWidth, height: window.innerHeight };

// Função para detectar DevTools aberto
function detectDevTools() {
    const threshold = 160;
    const widthThreshold = window.outerWidth - window.innerWidth > threshold;
    const heightThreshold = window.outerHeight - window.innerHeight > threshold;
    
    if (widthThreshold || heightThreshold) {
        if (!devToolsOpen) {
            devToolsOpen = true;
            devToolsAttempts++;
            handleDevToolsDetection();
        }
    } else {
        devToolsOpen = false;
    }
}

// Função para lidar com detecção do DevTools
function handleDevToolsDetection() {
    // Aumenta a dificuldade drasticamente
    hoverCount += 10;
    attemptsEl.textContent = hoverCount;
    
    // Efeito visual de punição
    document.body.style.background = '#ff0000';
    document.body.style.animation = 'shake 0.1s ease-in-out infinite';
    
    // Mostra aviso
    alert(`🚫 DEVTOOLS DETECTADO! 🚫\nTentativa ${devToolsAttempts}/3\nO jogo ficou mais difícil!`);
    
    // Reset visual após 2 segundos
    setTimeout(() => {
        document.body.style.background = '#050d1a';
        document.body.style.animation = 'none';
    }, 2000);
    
    // Game over após 3 tentativas
    if (devToolsAttempts >= 3) {
        alert('💀 GAME OVER! 💀\nMuitas tentativas de burlar o sistema!');
        location.href = 'about:blank';
    }
}

// Detecção de redimensionamento suspeito
function detectSuspiciousResize() {
    const currentWidth = window.innerWidth;
    const currentHeight = window.innerHeight;
    
    // Detecta mudanças bruscas de tamanho (possível DevTools)
    if (Math.abs(currentWidth - lastWindowSize.width) > 200 || 
        Math.abs(currentHeight - lastWindowSize.height) > 200) {
        handleDevToolsDetection();
    }
    
    lastWindowSize = { width: currentWidth, height: currentHeight };
}

// Proteção contra inspeção de elementos
function protectElements() {
    // Remove event listeners se alguém tentar inspecionar
    const originalAddEventListener = Element.prototype.addEventListener;
    Element.prototype.addEventListener = function(type, listener, options) {
        if (type === 'contextmenu' || type === 'keydown') {
            return;
        }
        return originalAddEventListener.call(this, type, listener, options);
    };
}

// Proteção contra console (versão mais suave)
function protectConsole() {
    // Apenas intercepta tentativas de debug, mas não quebra o console completamente
    const originalLog = console.log;
    console.log = function(...args) {
        // Detecta tentativas de debug
        if (args.some(arg => typeof arg === 'string' && 
            (arg.includes('debug') || arg.includes('devtools') || arg.includes('inspect')))) {
            handleDevToolsDetection();
        }
        return originalLog.apply(this, args);
    };
}

// Proteção contra debugger (versão mais suave)
function protectDebugger() {
    // Detecta uso de debugger apenas ocasionalmente
    setInterval(() => {
        if (devToolsOpen) {
            const start = performance.now();
            debugger;
            const end = performance.now();
            
            if (end - start > 100) {
                handleDevToolsDetection();
            }
        }
    }, 3000); // Verifica a cada 3 segundos em vez de 1
}

// Proteção contra atalhos de teclado
function protectKeyboard() {
    document.addEventListener('keydown', (e) => {
        // F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U, Ctrl+S
        if (e.key === 'F12' || 
            (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) ||
            (e.ctrlKey && (e.key === 'u' || e.key === 's'))) {
            e.preventDefault();
            handleDevToolsDetection();
            return false;
        }
    });
}

// Proteção contra clique direito
function protectContextMenu() {
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        handleDevToolsDetection();
        return false;
    });
}

// Proteção contra seleção de texto
function protectSelection() {
    document.addEventListener('selectstart', (e) => {
        e.preventDefault();
        return false;
    });
}

// Ofuscação de variáveis importantes
function obfuscateVariables() {
    // Renomeia variáveis críticas
    window['_0x1a2b'] = hoverCount;
    window['_0x3c4d'] = gameStarted;
    window['_0x5e6f'] = devToolsOpen;
}

// Inicialização das proteções
function initAntiDevTools() {
    protectConsole();
    protectElements();
    protectKeyboard();
    protectContextMenu();
    protectSelection();
    obfuscateVariables();
    
    // Monitoramento contínuo
    setInterval(detectDevTools, 500);
    setInterval(detectSuspiciousResize, 1000);
    setInterval(protectDebugger, 1000);
    
    // Monitora mudanças no DOM
    const observer = new MutationObserver(() => {
        if (devToolsOpen) {
            handleDevToolsDetection();
        }
    });
    observer.observe(document.body, { childList: true, subtree: true });
}

// Proteção adicional contra manipulação de código
function protectCodeIntegrity() {
    // Protege funções críticas
    const originalEval = window.eval;
    window.eval = function(code) {
        handleDevToolsDetection();
        return originalEval.call(this, code);
    };
    
    // Protege Function constructor
    const originalFunction = window.Function;
    window.Function = function(...args) {
        handleDevToolsDetection();
        return originalFunction.apply(this, args);
    };
    
    // Protege setTimeout/setInterval
    const originalSetTimeout = window.setTimeout;
    window.setTimeout = function(fn, delay) {
        if (typeof fn === 'string') {
            handleDevToolsDetection();
        }
        return originalSetTimeout.call(this, fn, delay);
    };
}

// Proteção contra modificação de propriedades (versão mais suave)
function protectProperties() {
    // Apenas monitora tentativas de modificação via window
    const originalDefineProperty = Object.defineProperty;
    Object.defineProperty = function(obj, prop, descriptor) {
        if (obj === window && (prop === 'hoverCount' || prop === 'gameStarted')) {
            handleDevToolsDetection();
        }
        return originalDefineProperty.call(this, obj, prop, descriptor);
    };
}

// Proteção contra iframe injection
function protectIframe() {
    if (window !== window.top) {
        handleDevToolsDetection();
    }
}

// Proteção contra source maps
function protectSourceMaps() {
    // Remove source maps se existirem
    const scripts = document.querySelectorAll('script');
    scripts.forEach(script => {
        if (script.src && script.src.includes('sourcemap')) {
            script.remove();
        }
    });
}

// Proteção contra extensões do navegador
function protectExtensions() {
    // Detecta extensões suspeitas
    const suspiciousProps = ['chrome', 'browser', 'extension'];
    suspiciousProps.forEach(prop => {
        if (window[prop]) {
            handleDevToolsDetection();
        }
    });
}

// Proteção contra modificação de CSS (versão mais suave)
function protectCSS() {
    // Apenas adiciona proteção básica de seleção
    const style = document.createElement('style');
    style.textContent = `
        body { 
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    `;
    document.head.appendChild(style);
}

// Inicialização das proteções (versão simplificada)
function initAntiDevTools() {
    protectKeyboard();
    protectContextMenu();
    protectSelection();
    protectCSS();
    
    // Monitoramento contínuo (menos agressivo)
    setInterval(detectDevTools, 1000);
    setInterval(detectSuspiciousResize, 2000);
    setInterval(protectDebugger, 5000);
}

// Sistema de detecção de tempo (anti-burla)
function initTimeProtection() {
    let startTime = Date.now();
    let lastCheck = startTime;
    
    setInterval(() => {
        const currentTime = Date.now();
        const expectedTime = lastCheck + 1000; // Espera 1 segundo entre checks
        const timeDiff = Math.abs(currentTime - expectedTime);
        
        // Se a diferença for muito grande, pode ser manipulação de tempo
        if (timeDiff > 2000) {
            handleDevToolsDetection();
        }
        
        lastCheck = currentTime;
    }, 1000);
}

// Proteção contra manipulação de performance
function protectPerformance() {
    // Apenas monitora, não substitui completamente
    let lastNow = performance.now();
    
    setInterval(() => {
        const current = performance.now();
        const diff = current - lastNow;
        
        // Detecta manipulação do performance.now apenas se muito suspeito
        if (diff < -1000 || diff > 50000) {
            handleDevToolsDetection();
        }
        
        lastNow = current;
    }, 2000);
}

// Proteção contra modificação de Date (versão mais suave)
function protectDate() {
    // Apenas monitora mudanças suspeitas, não substitui Date
    let lastDate = new Date();
    
    setInterval(() => {
        const current = new Date();
        const diff = current - lastDate;
        
        // Detecta manipulação de data apenas se muito suspeito
        if (Math.abs(diff) > 10000) {
            handleDevToolsDetection();
        }
        
        lastDate = current;
    }, 2000);
}

// Proteção contra modificação de Math.random (versão mais suave)
function protectRandom() {
    // Apenas monitora uso excessivo, não substitui Math.random
    let callCount = 0;
    const originalRandom = Math.random;
    
    setInterval(() => {
        callCount = 0; // Reset contador a cada intervalo
    }, 5000);
    
    // Intercepta apenas chamadas suspeitas
    const originalRandomCall = Math.random;
    Math.random = function() {
        callCount++;
        
        // Detecta uso excessivo de random apenas se muito suspeito
        if (callCount > 5000) {
            handleDevToolsDetection();
        }
        
        return originalRandomCall();
    };
}

// Proteção contra modificação de localStorage/sessionStorage (versão mais suave)
function protectStorage() {
    // Apenas monitora tentativas de debug via storage
    const originalSetItem = Storage.prototype.setItem;
    
    Storage.prototype.setItem = function(key, value) {
        if (typeof key === 'string' && (key.includes('devtools') || key.includes('debug'))) {
            handleDevToolsDetection();
        }
        return originalSetItem.call(this, key, value);
    };
}

// Inicia as proteções imediatamente (versão simplificada)
initAntiDevTools();

// ===========================================
// CÓDIGO DO JOGO (PROTEGIDO)
// ===========================================

const gameContainer = document.querySelector('.game');
const btn1 = document.getElementById('btn1');
const chapolin = document.getElementById('chapolin');
const chapolinHammer = document.getElementById('chapolinHammer');
const attemptsEl = document.getElementById('attempts');
const difficultyEl = document.getElementById('difficulty');
const stageEl = document.getElementById('stage');
const difficultyProgress = document.getElementById('difficultyProgress');
const volumeLevel = document.getElementById('volumeLevel');
const volumeText = document.getElementById('volumeText');
const bgMusic = document.getElementById('bgMusic');
const explosionSound = document.getElementById('explosionSound');
const boomSound = document.getElementById('boomSound');
const finalAttempts = document.getElementById('finalAttempts');

// Áudios do Chapolin
const chapolinVictory = document.getElementById('chapolinVictory');
const chapolinCheat = document.getElementById('chapolinCheat');
const chapolinDefeat1 = document.getElementById('chapolinDefeat1');
const chapolinDefeat2 = document.getElementById('chapolinDefeat2');
const chapolinDefeat3 = document.getElementById('chapolinDefeat3');
const chapolinDefeat4 = document.getElementById('chapolinDefeat4');

let hoverCount = 0;
let gameStarted = false;
let lastMouseX = 0;
let lastMouseY = 0;

// Variáveis para efeitos troll
let fakeButtons = [];
let trollMessages = [
  "Quase lá! 😈",
  "Você está indo bem! (mentira)",
  "Só mais uma tentativa! (ou não)",
  "Dica: Use o F12! (pegadinha)",
  "Parabéns! Você ganhou! (não)",
  "Nível 2 desbloqueado! (falso)",
  "Prêmio: $1000! (mentira)",
  "Loading... (infinito)",
  "Quase conseguiu! (não)",
  "Muito bom! (não é)"
];
let currentTrollMessage = 0;

// Sistema de Cheats (GTA Style)
let cheatBuffer = '';
let activeCheats = {
  easy: false,
  hard: false,
  admin: false,
  godmode: false
};
let cheatMessages = {
  easy: "CHEAT ATIVADO: EASY MODE! 🎮",
  hard: "CHEAT ATIVADO: HARD MODE! 😈",
  admin: "CHEAT ATIVADO: ADMIN MODE! 👑",
  godmode: "CHEAT ATIVADO: GOD MODE! 🛡️"
};

// Inicializa o áudio
bgMusic.volume = 0.1;

// Sistema de controle de volume inteligente
let originalVolume = 0.1;
let isPlayingChapolinAudio = false;

function lowerBackgroundMusic() {
  if (!isPlayingChapolinAudio) {
    originalVolume = bgMusic.volume;
    bgMusic.volume = 0.05; // Abaixa para 5%
    isPlayingChapolinAudio = true;
  }
}

function restoreBackgroundMusic() {
  if (isPlayingChapolinAudio) {
    bgMusic.volume = originalVolume;
    isPlayingChapolinAudio = false;
  }
}

function playChapolinAudio(audioElement, callback = null) {
  // Remove event listeners anteriores para evitar múltiplas chamadas
  audioElement.removeEventListener('ended', restoreBackgroundMusic);
  
  lowerBackgroundMusic();
  
  audioElement.volume = 0.8;
  audioElement.currentTime = 0;
  
  const playPromise = audioElement.play();
  
  if (playPromise !== undefined) {
    playPromise.then(() => {
      // Áudio começou a tocar
      console.log('Áudio do Chapolin tocando');
    }).catch(error => {
      console.log('Erro ao tocar áudio do Chapolin:', error);
      restoreBackgroundMusic();
    });
  }
  
  // Restaura volume quando o áudio terminar
  audioElement.addEventListener('ended', () => {
    restoreBackgroundMusic();
    if (callback) callback();
  });
}

// Funções específicas para cada tipo de áudio
function playVictoryAudio() {
  playChapolinAudio(chapolinVictory);
}

function playCheatAudio() {
  playChapolinAudio(chapolinCheat);
}

function playDefeatAudio() {
  // Escolhe um áudio aleatório de derrota
  const defeatAudios = [chapolinDefeat1, chapolinDefeat2, chapolinDefeat3, chapolinDefeat4];
  const randomAudio = defeatAudios[Math.floor(Math.random() * defeatAudios.length)];
  playChapolinAudio(randomAudio);
}

// Sistema de áudio épico para explosão
function createExplosionAudio() {
    let audioContext = null;
    
    // Função para inicializar AudioContext
    function initAudioContext() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
    }
    
    // Função para criar tom com frequência específica
    function createTone(frequency, duration, volume = 0.1) {
        try {
            initAudioContext();
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sawtooth';
            
            // Envelope de volume crescente
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + duration * 0.1);
            gainNode.gain.linearRampToValueAtTime(volume * 0.8, audioContext.currentTime + duration * 0.8);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        } catch (e) {
            console.log('Erro no áudio:', e);
        }
    }
    
    // Função para criar ruído branco (explosão)
    function createWhiteNoise(duration, volume = 0.1) {
        try {
            initAudioContext();
            if (!audioContext) return;
            
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                output[i] = (Math.random() * 2 - 1) * volume;
            }
            
            const whiteNoise = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            
            whiteNoise.buffer = buffer;
            whiteNoise.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Envelope crescente
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + duration * 0.2);
            gainNode.gain.linearRampToValueAtTime(volume * 0.3, audioContext.currentTime + duration * 0.8);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
            
            whiteNoise.start(audioContext.currentTime);
            whiteNoise.stop(audioContext.currentTime + duration);
        } catch (e) {
            console.log('Erro no ruído:', e);
        }
    }
    
    // Função para criar BOOM final
    function createBoom() {
        try {
            initAudioContext();
            if (!audioContext) return;
            
            // Múltiplas frequências para efeito de BOOM
            createTone(60, 0.5, 0.3);  // Grave
            createTone(120, 0.4, 0.2); // Médio
            createTone(240, 0.3, 0.1); // Agudo
            createWhiteNoise(0.8, 0.4); // Ruído de explosão
        } catch (e) {
            console.log('Erro no BOOM:', e);
        }
    }
    
    return { createTone, createWhiteNoise, createBoom };
}

// Inicializa o sistema de áudio
const explosionAudio = createExplosionAudio();

// Funções para efeitos troll
function showTrollMessage() {
  const message = trollMessages[currentTrollMessage % trollMessages.length];
  currentTrollMessage++;
  
  // Cria popup troll
  const trollPopup = document.createElement('div');
  trollPopup.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #ff0000;
    color: white;
    padding: 10px 20px;
    border-radius: 10px;
    font-weight: bold;
    z-index: 9999;
    animation: textReveal 0.5s ease-out forwards;
    box-shadow: 0 0 20px rgba(255,0,0,0.5);
  `;
  trollPopup.textContent = message;
  document.body.appendChild(trollPopup);
  
  // Remove após 3 segundos
  setTimeout(() => {
    trollPopup.remove();
  }, 3000);
}

function createFakeButtons() {
  // Remove botões falsos anteriores
  fakeButtons.forEach(btn => btn.remove());
  fakeButtons = [];
  
  // Cria 3-5 botões falsos
  const fakeCount = 3 + Math.floor(Math.random() * 3);
  for (let i = 0; i < fakeCount; i++) {
    const fakeBtn = document.createElement('div');
    fakeBtn.className = 'big-btn fakeButton';
    fakeBtn.textContent = '🎯 FALSO 🎯';
    fakeBtn.style.cssText = `
      position: absolute;
      left: ${Math.random() * (gameContainer.clientWidth - 200)}px;
      top: ${Math.random() * (gameContainer.clientHeight - 100)}px;
      background: #ff0000;
      color: white;
      z-index: 5;
      pointer-events: auto;
    `;
    
    // Adiciona evento de clique troll
    fakeBtn.addEventListener('click', () => {
      showTrollMessage();
      fakeBtn.style.background = '#ff6666';
      fakeBtn.textContent = 'HAHA! 😈';
      setTimeout(() => fakeBtn.remove(), 1000);
    });
    
    gameContainer.appendChild(fakeBtn);
    fakeButtons.push(fakeBtn);
  }
  
  // Remove botões falsos após 5 segundos
  setTimeout(() => {
    fakeButtons.forEach(btn => btn.remove());
    fakeButtons = [];
  }, 5000);
}

function addGlitchEffect() {
  document.body.classList.add('glitch');
  setTimeout(() => {
    document.body.classList.remove('glitch');
  }, 1000);
}

function addLagEffect() {
  document.body.classList.add('lag');
  setTimeout(() => {
    document.body.classList.remove('lag');
  }, 2000);
}

function addScreenFlicker() {
  document.body.classList.add('screenFlicker');
  setTimeout(() => {
    document.body.classList.remove('screenFlicker');
  }, 500);
}

function playChapolinLaugh() {
  // Simula risada do Chapolin com áudio sintético
  if (explosionAudio) {
    explosionAudio.createTone(200, 0.3, 0.2);
    explosionAudio.createTone(300, 0.2, 0.15);
    explosionAudio.createTone(400, 0.3, 0.2);
  }
}

function playErrorSound() {
  // Som de erro do Windows
  if (explosionAudio) {
    explosionAudio.createTone(150, 0.1, 0.1);
    explosionAudio.createTone(100, 0.1, 0.1);
    explosionAudio.createTone(50, 0.1, 0.1);
  }
}

// SISTEMA DE CHEATS GTA STYLE! 🎮
function initCheatSystem() {
  document.addEventListener('keydown', (e) => {
    // Adiciona a tecla ao buffer
    cheatBuffer += e.key.toLowerCase();
    
    // Mantém apenas as últimas 10 teclas
    if (cheatBuffer.length > 10) {
      cheatBuffer = cheatBuffer.slice(-10);
    }
    
    // Verifica cheats
    checkCheats();
  });
}

function checkCheats() {
  const cheats = ['easy', 'hard', 'admin', 'godmode'];
  
  cheats.forEach(cheat => {
    if (cheatBuffer.endsWith(cheat)) {
      activateCheat(cheat);
    }
  });
}

function activateCheat(cheat) {
  // Desativa outros cheats
  Object.keys(activeCheats).forEach(key => {
    activeCheats[key] = false;
  });
  
  // Ativa o cheat
  activeCheats[cheat] = true;
  
  // Mostra mensagem
  showCheatMessage(cheat);
  
  // Som de cheat
  playCheatSound();
  
  // Mostra indicador visual
  const cheatIndicator = document.getElementById('cheatIndicator');
  cheatIndicator.style.display = 'block';
  cheatIndicator.style.background = '#ff0000';
  cheatIndicator.style.color = '#ffffff';
  cheatIndicator.textContent = `💎 ${cheat.toUpperCase()} ATIVO`;
  
  // Limpa buffer
  cheatBuffer = '';
  
  // Aplica efeitos do cheat
  applyCheatEffects(cheat);
}

function showCheatMessage(cheat) {
  const message = document.createElement('div');
  message.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(45deg, #ff0000, #ffff00);
    color: #000;
    padding: 20px 40px;
    border-radius: 15px;
    font-size: 2rem;
    font-weight: bold;
    z-index: 10000;
    animation: textReveal 0.5s ease-out forwards;
    box-shadow: 0 0 30px rgba(255,255,0,0.8);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  `;
  message.textContent = cheatMessages[cheat];
  document.body.appendChild(message);
  
  setTimeout(() => {
    message.remove();
  }, 3000);
}

function playCheatSound() {
  // Toca áudio do Chapolin para cheat
  playCheatAudio();
  
  // Também toca som sintético
  if (explosionAudio) {
    explosionAudio.createTone(200, 0.2, 0.2);
    explosionAudio.createTone(300, 0.2, 0.2);
    explosionAudio.createTone(400, 0.2, 0.2);
  }
}

function applyCheatEffects(cheat) {
  switch(cheat) {
    case 'easy':
      // Botão fica maior e mais lento
      btn1.style.transform = 'scale(1.5)';
      btn1.style.transition = 'all 1s ease';
      break;
    case 'hard':
      // Botão fica menor e mais rápido
      btn1.style.transform = 'scale(0.7)';
      btn1.style.transition = 'all 0.1s ease';
      break;
    case 'admin':
      // Botão fica no centro e não foge
      centerButton();
      btn1.style.transition = 'none';
      break;
    case 'godmode':
      // Efeito visual épico
      document.body.style.background = 'linear-gradient(45deg, #ff0000, #ffff00, #00ff00)';
      break;
  }
}

// VITÓRIA ÉPICA COM MARTELO DO CHAPOLIN! 🎬
function showVictorySequence() {
  const btnRect = btn1.getBoundingClientRect();
  const gameRect = gameContainer.getBoundingClientRect();
  const centerX = btnRect.left - gameRect.left + btn1.offsetWidth/2;
  const centerY = btnRect.top - gameRect.top + btn1.offsetHeight/2;
  
  // === FASE 1: MARTELO APARECE ===
  chapolinHammer.style.left = (centerX - 60) + "px";
  chapolinHammer.style.top = (centerY - 60) + "px";
  chapolinHammer.style.display = "block";
  chapolinHammer.style.zIndex = "10000";
  chapolinHammer.classList.add('hammerSwing');
  
  // Som de vitória épico do Chapolin
  playVictoryAudio();
  
  // Também toca som sintético
  if (explosionAudio) {
    explosionAudio.createTone(300, 0.5, 0.3);
    explosionAudio.createTone(400, 0.4, 0.2);
    explosionAudio.createTone(500, 0.3, 0.1);
  }
  
  // === FASE 2: CONFETTI ÉPICO ===
  setTimeout(() => {
    // Cria confetti colorido
    for (let i = 0; i < 50; i++) {
      const confetti = document.createElement('div');
      confetti.style.cssText = `
        position: absolute;
        left: ${centerX + (Math.random() - 0.5) * 200}px;
        top: ${centerY + (Math.random() - 0.5) * 200}px;
        width: 10px;
        height: 10px;
        background: ${['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#ff00ff', '#ffffff'][Math.floor(Math.random() * 6)]};
        border-radius: 50%;
        pointer-events: none;
        z-index: 9999;
      `;
      confetti.classList.add('victoryConfetti');
      gameContainer.appendChild(confetti);
      
      // Remove confetti após animação
      setTimeout(() => confetti.remove(), 3000);
    }
  }, 500);
  
  // === FASE 3: MARTELO VOANDO ===
  setTimeout(() => {
    chapolinHammer.classList.remove('hammerSwing');
    chapolinHammer.classList.add('hammerVictory');
  }, 1000);
  
  // === FASE 4: TEXTO DE VITÓRIA ÉPICO ===
  setTimeout(() => {
    const victoryOverlay = document.createElement('div');
    victoryOverlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(45deg, #ff0000, #ffff00, #00ff00, #00ffff, #ff00ff);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      font-family: 'Arial Black', sans-serif;
    `;
    
    victoryOverlay.innerHTML = `
      <div style="text-align: center; animation: victoryText 1s ease-out forwards;">
        <div style="
          font-size: 8rem;
          font-weight: bold;
          color: #ffffff;
          text-shadow: 0 0 30px #000, 0 0 60px #000, 0 0 90px #000;
          margin-bottom: 30px;
          animation: chapolinTextShake 0.3s ease-in-out infinite;
        ">
          🎉 VITÓRIA ÉPICA! 🎉
        </div>
        <div style="
          font-size: 4rem;
          font-weight: bold;
          color: #ffff00;
          text-shadow: 0 0 20px #000, 0 0 40px #000;
          margin-bottom: 40px;
          animation: victoryText 1.5s ease-out forwards;
        ">
          CHAPOLIN TE DEU O MARTELO!
        </div>
        <div style="
          font-size: 3rem;
          font-weight: bold;
          color: #ff8800;
          text-shadow: 0 0 15px #000, 0 0 30px #000;
          margin-bottom: 50px;
          animation: victoryText 2s ease-out forwards;
        ">
          🏆 VOCÊ É O CAMPEÃO! 🏆
        </div>
        <div style="
          font-size: 2rem;
          color: #ffffff;
          text-shadow: 0 0 10px #000;
          margin-bottom: 60px;
          animation: victoryText 2.5s ease-out forwards;
        ">
          ${hoverCount} tentativas - IMPRESSIONANTE!
        </div>
        <div style="
          font-size: 1.5rem;
          color: #cccccc;
          animation: victoryText 3s ease-out forwards;
        ">
          Clique para jogar novamente...
        </div>
      </div>
    `;
    
    document.body.appendChild(victoryOverlay);
    
    // Adiciona evento de clique para recarregar
    victoryOverlay.addEventListener('click', () => {
      location.reload();
    });
    
    // Remove martelo após 3 segundos
    setTimeout(() => {
      chapolinHammer.style.display = 'none';
      chapolinHammer.classList.remove('hammerVictory');
    }, 3000);
    
  }, 2000);
}

// Função para garantir que a música continue tocando
function ensureMusicPlaying() {
    if (gameStarted && bgMusic.paused) {
        bgMusic.play().catch(e => {
            console.log('Erro ao retomar música:', e);
        });
    }
}

// Verifica periodicamente se a música está tocando
setInterval(ensureMusicPlaying, 1000);

// Função para iniciar o jogo (e a música)
function startGame() {
    if (!gameStarted) {
        gameStarted = true;
        // Tenta tocar a música
        bgMusic.play().catch(e => {
            console.log('Autoplay bloqueado, clique para iniciar');
        });
        
        // Garante que a música está tocando
        if (bgMusic.paused) {
            bgMusic.play().catch(e => {
                console.log('Erro ao tocar música:', e);
            });
        }
    }
}

// Atualiza volume baseado na dificuldade
function updateVolume() {
    let volume = 0.1;
    
    if (hoverCount >= 5) volume = 0.4;
    if (hoverCount >= 10) volume = 0.6;
    if (hoverCount >= 15) volume = 1.0;
    if (hoverCount >= 20) volume = 1.2;
    if (hoverCount >= 25) volume = 1.5;
    if (hoverCount >= 28) volume = 2.0; // Volume estourado!
    
    // Aplica o volume com um efeito suave
    bgMusic.volume = Math.min(volume, 1.0); // Limita a 1.0 para navegadores seguros
    volumeLevel.style.width = (volume * 100) + '%';
    volumeText.textContent = Math.min(Math.round(volume * 100), 100) + '%';
    
    // Efeito visual quando o volume está alto
    if (volume >= 0.8) {
        volumeLevel.style.background = '#ef4444';
        document.body.style.animation = volume >= 1.0 ? 'shake 0.1s ease-in-out infinite' : 'none';
    } else {
        volumeLevel.style.background = '#10b981';
        document.body.style.animation = 'none';
    }
}

// Atualiza a dificuldade visual
function updateDifficulty() {
    const progress = (hoverCount / 30) * 100;
    difficultyProgress.style.width = progress + '%';
    
    if (hoverCount < 5) {
        difficultyEl.textContent = "Fácil";
        difficultyEl.style.color = "#10b981";
    } else if (hoverCount < 10) {
        difficultyEl.textContent = "Médio";
        difficultyEl.style.color = "#f59e0b";
    } else if (hoverCount < 20) {
        difficultyEl.textContent = "Difícil";
        difficultyEl.style.color = "#fb923c";
        btn1.classList.add('danger');
    } else {
        difficultyEl.textContent = "EXTREMO!";
        difficultyEl.style.color = "#ef4444";
    }
}

// Define posição inicial no centro do container do jogo
function centerButton() {
    btn1.style.left = (gameContainer.clientWidth/2 - btn1.offsetWidth/2) + 'px';
    btn1.style.top = (gameContainer.clientHeight/2 - btn1.offsetHeight/2) + 'px';
}

// Aguarda o carregamento para posicionar corretamente
window.addEventListener('load', centerButton);
window.addEventListener('resize', centerButton);

// Limita posição dentro do container do jogo com margem de segurança
function getRandomPosition(){
    const margin = 30; // Margem de segurança para não ficar muito perto das bordas
    const maxX = gameContainer.clientWidth - btn1.offsetWidth - margin*2;
    const maxY = gameContainer.clientHeight - btn1.offsetHeight - margin*2;
    let x = Math.random() * maxX + margin;
    let y = Math.random() * maxY + margin;
    x = Math.max(margin, Math.min(x, maxX + margin));
    y = Math.max(margin, Math.min(y, maxY + margin));
    return {x,y};
}

// Posiciona o botão longe do cursor
function getPositionAwayFromCursor(){
    const margin = 50;
    const maxX = gameContainer.clientWidth - btn1.offsetWidth - margin*2;
    const maxY = gameContainer.clientHeight - btn1.offsetHeight - margin*2;
    
    // Calcula a direção oposta ao cursor
    const btnRect = btn1.getBoundingClientRect();
    const gameRect = gameContainer.getBoundingClientRect();
    const btnCenterX = btnRect.left + btnRect.width/2;
    const btnCenterY = btnRect.top + btnRect.height/2;
    
    const deltaX = lastMouseX - btnCenterX;
    const deltaY = lastMouseY - btnCenterY;
    
    // Normaliza a direção
    const distance = Math.sqrt(deltaX*deltaX + deltaY*deltaY);
    const dirX = deltaX / distance;
    const dirY = deltaY / distance;
    
    // Move na direção oposta
    let newX = btnRect.left - gameRect.left - dirX * 150;
    let newY = btnRect.top - gameRect.top - dirY * 150;
    
    // Garante que está dentro dos limites
    newX = Math.max(margin, Math.min(newX, maxX + margin));
    newY = Math.max(margin, Math.min(newY, maxY + margin));
    
    return {x: newX, y: newY};
}

function updateButtonColor(){
  if(hoverCount < 10) {
      btn1.style.background='green';
      btn1.style.color='#042018';
  } else if(hoverCount < 15) {
      btn1.style.background='yellow';
      btn1.style.color='#422006';
  } else if(hoverCount < 20) {
      btn1.style.background='orange';
      btn1.style.color='#451a03';
  } else {
      btn1.style.background='red';
      btn1.style.color='white';
  }
}

// Reduz o tamanho do botão conforme a dificuldade aumenta
function updateButtonSize() {
    const baseSize = 18; // Tamanho base da fonte
    const paddingReduction = Math.min(hoverCount * 0.7, 10); // Redução progressiva
    const fontSize = Math.max(baseSize - hoverCount * 0.3, 12); // Fonte menor
    
    btn1.style.padding = `${18 - paddingReduction}px ${34 - paddingReduction * 1.5}px`;
    btn1.style.fontSize = `${fontSize}px`;
}

// Chapolin dá tapa no botão (versão épica)
function chapolinTap(){
  const btnRect = btn1.getBoundingClientRect();
  const gameRect = gameContainer.getBoundingClientRect();
  
  chapolin.style.left = (btnRect.left - gameRect.left - 30) + "px";
  chapolin.style.top = (btnRect.top - gameRect.top - 30) + "px";
  chapolin.style.display = "block";
  chapolin.style.transition = "all 0.3s ease";
  chapolin.style.transform = "rotate(360deg) scale(1.2)";
  chapolin.style.filter = "brightness(1.5) drop-shadow(0 0 10px #ff0000)";
  chapolin.classList.add('chapolinSpin');

  // Efeito de tela piscando
  document.body.classList.add('megaShake');
  
  // Som de tapa épico
  bgMusic.playbackRate = 1.8;
  setTimeout(() => bgMusic.playbackRate = 1.0, 300);

  const pos = getRandomPosition();
  btn1.style.left = pos.x + "px";
  btn1.style.top = pos.y + "px";

  setTimeout(()=>{
    chapolin.style.display='none';
    chapolin.style.transform='rotate(0deg) scale(1)';
    chapolin.style.filter = 'none';
    chapolin.classList.remove('chapolinSpin');
    document.body.classList.remove('megaShake');
  },800);
}

// EXPLOSÃO ÉPICA FINAL - DIGNA DE OSCAR! 💥🎬
function explodeButton(){
  const btnRect = btn1.getBoundingClientRect();
  const gameRect = gameContainer.getBoundingClientRect();
  const centerX = btnRect.left - gameRect.left + btn1.offsetWidth/2;
  const centerY = btnRect.top - gameRect.top + btn1.offsetHeight/2;
  
  // === FASE 1: PREPARAÇÃO ÉPICA ===
  document.body.classList.add('megaShake');
  document.body.classList.add('screenFlash');
  
  // Chapolin aparece e começa a girar loucamente
  chapolin.style.left = (centerX - 50) + "px";
  chapolin.style.top = (centerY - 50) + "px";
  chapolin.style.display = "block";
  chapolin.style.zIndex = "9999";
  chapolin.classList.add('chapolinExplode');
  
  // Som épico de explosão - SISTEMA CRESCENTE
  bgMusic.playbackRate = 2.0;
  bgMusic.volume = 1.0;
  
  // Toca áudio de derrota do Chapolin
  playDefeatAudio();
  
  // SISTEMA DE ÁUDIO ÉPICO CRESCENTE
  // Efeito de explosão crescente usando a música de fundo
  let explosionStep = 0;
  const explosionInterval = setInterval(() => {
    explosionStep++;
    
    // Aumenta progressivamente a velocidade e volume
    bgMusic.playbackRate = 2.0 + (explosionStep * 0.1);
    bgMusic.volume = Math.min(1.0, 0.5 + (explosionStep * 0.05));
    
    // Tenta usar áudio sintético se disponível
    if (explosionAudio) {
      explosionAudio.createTone(80 + (explosionStep * 20), 0.2, 0.1 + (explosionStep * 0.02));
    }
    
    // Para após 7 passos (crescimento completo)
    if (explosionStep >= 7) {
      clearInterval(explosionInterval);
    }
  }, 100);
  
  // === FASE 2: ONDA DE CHOQUE ===
  setTimeout(() => {
    // Cria onda de choque
    const shockwave = document.createElement('div');
    shockwave.style.position = 'absolute';
    shockwave.style.left = centerX + 'px';
    shockwave.style.top = centerY + 'px';
    shockwave.style.width = '20px';
    shockwave.style.height = '20px';
    shockwave.style.background = 'radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,0,0,0.6) 50%, transparent 100%)';
    shockwave.style.borderRadius = '50%';
    shockwave.style.transform = 'translate(-50%, -50%)';
    shockwave.style.zIndex = '9998';
    shockwave.classList.add('shockwave');
    gameContainer.appendChild(shockwave);
    
    // Remove onda de choque após animação
    setTimeout(() => shockwave.remove(), 1000);
  }, 500);
  
  // === FASE 3: EXPLOSÃO DE PARTÍCULAS ÉPICA ===
  setTimeout(() => {
    const particles = [];
    const particleCount = 50; // Mais partículas para efeito épico
    
    for(let i = 0; i < particleCount; i++){
    const p = document.createElement('div');
    p.classList.add('particle');
      p.style.position = 'absolute';
      p.style.left = centerX + 'px';
      p.style.top = centerY + 'px';
      p.style.width = '15px';
      p.style.height = '15px';
      p.style.borderRadius = '50%';
      p.style.pointerEvents = 'none';
      p.style.zIndex = '9997';
      
      // Cores variadas para efeito épico
      const colors = ['#ff0000', '#ffff00', '#ff8800', '#ff0088', '#8800ff', '#00ffff', '#ffffff'];
      p.style.background = colors[Math.floor(Math.random() * colors.length)];
      p.style.boxShadow = '0 0 20px ' + colors[Math.floor(Math.random() * colors.length)];
      
    gameContainer.appendChild(p);
    particles.push(p);
      
      // Cálculo de direção épica
      const angle = (i / particleCount) * Math.PI * 2;
      const distance = 200 + Math.random() * 300;
      const dx = Math.cos(angle) * distance;
      const dy = Math.sin(angle) * distance;
      const rot = Math.random() * 720;
      
      // Aplica variáveis CSS para animação
      p.style.setProperty('--dx', dx + 'px');
      p.style.setProperty('--dy', dy + 'px');
      
      // Animação épica da partícula
      p.classList.add('particleExplode');
    }
    
    // === FASE 4: EFEITOS DE TELA ÉPICOS + BOOM FINAL ===
    // Flash de tela branca + BOOM ÉPICO
    setTimeout(() => {
      // BOOM FINAL ÉPICO!
      if (explosionAudio) {
        explosionAudio.createBoom();
      }
      
      // Efeito de áudio máximo
      bgMusic.playbackRate = 3.0;
      bgMusic.volume = 1.0;
      
      // Flash de tela branca
      const flash = document.createElement('div');
      flash.style.position = 'fixed';
      flash.style.top = '0';
      flash.style.left = '0';
      flash.style.width = '100vw';
      flash.style.height = '100vh';
      flash.style.background = 'white';
      flash.style.zIndex = '10000';
      flash.style.pointerEvents = 'none';
      document.body.appendChild(flash);
      
      // Efeito de "tela quebrada" após o flash
      setTimeout(() => {
        flash.style.background = 'linear-gradient(45deg, #ff0000, #ffff00, #ff0000)';
        flash.style.animation = 'screenFlash 0.1s ease-in-out infinite';
      }, 50);
      
      setTimeout(() => {
        flash.remove();
        // Reset do áudio
        bgMusic.playbackRate = 1.0;
        bgMusic.volume = 0.1;
        // Garante que a música continue tocando
        if (bgMusic.paused) {
          bgMusic.play().catch(e => console.log('Erro ao retomar música após explosão:', e));
        }
      }, 200);
    }, 1000);
    
    // === FASE 5: TEXTO ÉPICO DE GAME OVER - SEMPRE NO MEIO ===
    setTimeout(() => {
      // Remove qualquer texto anterior
      const existingText = document.getElementById('gameOverOverlay');
      if (existingText) {
        existingText.remove();
      }
      
      const gameOverText = document.createElement('div');
      gameOverText.id = 'gameOverOverlay';
      gameOverText.innerHTML = `
        <div style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background: rgba(0, 0, 0, 0.9);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10001;
          font-family: 'Arial Black', sans-serif;
        ">
          <div style="
            text-align: center;
            animation: textReveal 1s ease-out forwards;
          ">
            <div style="
              font-size: 6rem;
              font-weight: bold;
              color: #ff0000;
              text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000, 0 0 90px #ff0000;
              margin-bottom: 20px;
              animation: chapolinTextShake 0.3s ease-in-out infinite;
            ">
              💥💥💥 CHAPOLIN 💥💥💥
            </div>
            <div style="
              font-size: 4rem;
              font-weight: bold;
              color: #ffff00;
              text-shadow: 0 0 20px #ffff00, 0 0 40px #ffff00;
              margin-bottom: 30px;
              animation: textReveal 1.5s ease-out forwards;
            ">
              DESTRUIU TUDO!
            </div>
            <div style="
              font-size: 3rem;
              font-weight: bold;
              color: #ff8800;
              text-shadow: 0 0 15px #ff8800, 0 0 30px #ff8800;
              margin-bottom: 40px;
              animation: textReveal 2s ease-out forwards;
            ">
              🎆 EXPLOSÃO ÉPICA! 🎆
            </div>
            <div style="
              font-size: 2rem;
              color: #ffffff;
              text-shadow: 0 0 10px #ffffff;
              margin-bottom: 50px;
              animation: textReveal 2.5s ease-out forwards;
            ">
              GAME OVER TOTAL!
            </div>
            <div style="
              font-size: 1.5rem;
              color: #cccccc;
              animation: textReveal 3s ease-out forwards;
            ">
              Clique para recarregar e tentar novamente...
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(gameOverText);
      
      // Adiciona evento de clique para recarregar
      gameOverText.addEventListener('click', () => {
    location.reload();
      });
      
      // Remove partículas e reseta visual
      setTimeout(() => {
        particles.forEach(p => p.remove());
        document.body.classList.remove('megaShake', 'screenFlash');
        chapolin.style.display = 'none';
        chapolin.classList.remove('chapolinExplode');
        btn1.style.display = 'none';
      }, 2000);
      
    }, 1500);
    
  }, 800);
}

// Rastreia a posição do mouse
gameContainer.addEventListener('mousemove', (e) => {
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
});

// Hover no botão (versão troll épica com cheats)
btn1.addEventListener('mouseenter', ()=>{
  startGame(); // Inicia o jogo no primeiro hover
  hoverCount++;
  attemptsEl.textContent = hoverCount;
  
  updateButtonColor();
  updateButtonSize();
  updateDifficulty();
  updateVolume();

  // EFEITOS TROLL BASEADOS NA DIFICULDADE (respeitando cheats)
  if (hoverCount >= 3 && !activeCheats.easy) {
    // Risada do Chapolin quando o botão foge
    playChapolinLaugh();
  }
  
  if (hoverCount >= 5 && !activeCheats.easy) {
    // Efeito de lag na tela
    addLagEffect();
  }
  
  if (hoverCount >= 8 && !activeCheats.easy) {
    // Cria botões falsos
    createFakeButtons();
  }
  
  if (hoverCount >= 12 && !activeCheats.easy) {
    // Efeito de glitch
    addGlitchEffect();
  }
  
  if (hoverCount >= 15 && !activeCheats.easy) {
    // Flicker na tela
    addScreenFlicker();
  }
  
  if (hoverCount >= 20 && !activeCheats.easy) {
    // Mensagem troll
    showTrollMessage();
  }
  
  // EFEITO ESPECIAL NO 29 (quase lá!)
  if (hoverCount === 29 && !activeCheats.easy) {
    // Cria múltiplos botões falsos
    createFakeButtons();
    createFakeButtons(); // Duplo!
    
    // Efeito de tela piscando
    addScreenFlicker();
    
    // Mensagem especial
    const specialMessage = document.createElement('div');
    specialMessage.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #ffff00;
      color: #000;
      padding: 20px 40px;
      border-radius: 20px;
      font-size: 2rem;
      font-weight: bold;
      z-index: 10000;
      animation: textReveal 0.5s ease-out forwards;
      box-shadow: 0 0 30px rgba(255,255,0,0.8);
    `;
    specialMessage.textContent = "29/30! QUASE LÁ! 😈";
    document.body.appendChild(specialMessage);
    
    setTimeout(() => {
      specialMessage.remove();
    }, 2000);
  }

  if(hoverCount >=5 && hoverCount <30 && !activeCheats.easy){
    chapolinTap();
  }

  if(hoverCount >=30){
    explodeButton();
  } else {
    // SISTEMA DE FUGA BASEADO NOS CHEATS
    if (activeCheats.admin) {
      // Admin mode: botão não foge
      return;
    }
    
    if (activeCheats.godmode) {
      // God mode: botão foge muito devagar
      setTimeout(() => {
        const pos = getRandomPosition();
        btn1.style.left = pos.x + "px";
        btn1.style.top = pos.y + "px";
      }, 2000);
      return;
    }
    
    // Cálculo de velocidade baseado nos cheats
    let escapeSpeed = Math.min(50 + (hoverCount * 5), 200);
    let transitionSpeed = Math.max(0.1, 0.5 - hoverCount * 0.015);
    
    if (activeCheats.easy) {
      escapeSpeed *= 3; // 3x mais lento
      transitionSpeed *= 2; // 2x mais lento
    }
    
    if (activeCheats.hard) {
      escapeSpeed *= 0.5; // 2x mais rápido
      transitionSpeed *= 0.5; // 2x mais rápido
    }
    
    setTimeout(() => {
      // 30% de chance de movimento aleatório, 70% de fuga inteligente
      let pos;
      if (Math.random() < 0.3) {
        pos = getRandomPosition(); // Movimento aleatório
      } else {
        pos = getPositionAwayFromCursor(); // Foge do cursor
      }
      
      btn1.style.transition = `all ${transitionSpeed}s ease`;
      btn1.style.left = pos.x + "px";
      btn1.style.top = pos.y + "px";
    }, escapeSpeed);
  }
});

// Clique no botão (versão troll épica com cheats)
btn1.addEventListener('click', ()=>{
  if(hoverCount < 30){
    // Efeito de clique troll (apenas se não estiver em easy mode)
    if (!activeCheats.easy) {
      playErrorSound();
      addGlitchEffect();
    }
    
    // SISTEMA DE VITÓRIA BASEADO NOS CHEATS
    if (activeCheats.admin) {
      // Admin mode: vitória instantânea
      showVictorySequence();
      return;
    }
    
    if (activeCheats.godmode) {
      // God mode: vitória após 5 tentativas
      if (hoverCount >= 5) {
        showVictorySequence();
        return;
      }
    }
    
    if (activeCheats.easy) {
      // Easy mode: vitória após 10 tentativas
      if (hoverCount >= 10) {
        showVictorySequence();
        return;
      }
    }
    
    // Modo normal: vitória após 25 tentativas
    if (hoverCount < 25) {
      if (!activeCheats.easy) {
        showTrollMessage();
        // Botão foge mesmo após clique
        setTimeout(() => {
          const pos = getPositionAwayFromCursor();
          btn1.style.left = pos.x + "px";
          btn1.style.top = pos.y + "px";
        }, 100);
      }
    } else {
      // VITÓRIA REAL ÉPICA COM MARTELO!
      showVictorySequence();
    }
  }
});

// Play again
document.getElementById('playAgain').onclick = ()=>location.reload();

// Inicia a música ao clicar em qualquer lugar da página (para desbloquear autoplay)
document.addEventListener('click', startGame);

// Inicializa o sistema de cheats
initCheatSystem();

// Tenta iniciar a música automaticamente após um pequeno delay
setTimeout(() => {
    if (!gameStarted) {
        startGame();
    }
}, 500);

// Adiciona evento para quando a música para
bgMusic.addEventListener('ended', () => {
    if (gameStarted) {
        bgMusic.currentTime = 0;
        bgMusic.play().catch(e => console.log('Erro ao reiniciar música:', e));
    }
});

// Adiciona evento para quando a música é pausada
bgMusic.addEventListener('pause', () => {
    if (gameStarted) {
        setTimeout(() => {
            if (bgMusic.paused) {
                bgMusic.play().catch(e => console.log('Erro ao retomar música pausada:', e));
            }
        }, 100);
    }
});
</script>
</body>
</html>
